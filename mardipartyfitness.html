<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wooly Willy – Magnetic Hair (Enhanced)</title>

<!-- ✅ AdSense Auto Ads (your client ID) -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3503638702287231" crossorigin="anonymous"></script>

<style>
  :root {
    --red:#c00; --bg:#f4f4f6; --ink:#222;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    display:flex; flex-direction:column; align-items:center; min-height:100svh;
  }
  header{padding:8px 12px; text-align:center}
  h1{margin:.2rem 0 .4rem; color:var(--red); letter-spacing:.5px; font-size:1.2rem}
  .card{
    background:#fff; border:6px solid var(--red); border-radius:18px;
    box-shadow:0 6px 18px rgba(0,0,0,.08);
    overflow:hidden; width:min(92vw,560px);
  }
  .topbar{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
    padding:10px 12px; background:#fff; border-bottom:1px solid #eee;
  }
  .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  button{
    background:var(--red); color:#fff; border:none; border-radius:10px;
    padding:8px 12px; font-size:.95rem; cursor:pointer;
  }
  button.secondary{background:#444}
  button:active{transform:translateY(1px)}
  label{font-size:.9rem; color:#333; white-space:nowrap}
  input[type=range]{width:130px}
  .stage{ position:relative; background:#fefefe; display:block; width:100%; aspect-ratio:1/1; touch-action:none; }
  svg.face{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }
  canvas#filings{ position:absolute; inset:0; width:100%; height:100% }
  footer{ width:100%; text-align:center; font-size:.8rem; color:#666; padding:10px 0 16px; }
  .row {display:flex; gap:12px; align-items:center; flex-wrap:wrap}
  .meter { font-size:.8rem; opacity:.7 }
</style>
</head>
<body>
  <header>
    <h1>Wooly Willy – Magnetic Hair</h1>
    <div style="opacity:.75;font-size:.9rem">Drag the filings to give Willy a beard, hair, and brows!</div>
  </header>

  <div class="card" id="app">
    <div class="topbar">
      <div class="controls row">
        <button id="clearBtn" title="Return filings to tray">Clear</button>
        <button id="reseedBtn" class="secondary" title="Reseed filings">Reseed</button>
      </div>
      <div class="controls row">
        <label for="strength">Magnet</label>
        <input id="strength" type="range" min="0" max="100" value="55" />
        <label for="count">Hair</label>
        <input id="count" type="range" min="800" max="8000" value="3500" />
        <span class="meter" id="countLabel">3,500</span>
      </div>
    </div>

    <!-- Playfield -->
    <div class="stage" id="stage">
      <!-- Face (inline SVG) -->
      <svg class="face" viewBox="0 0 1000 1000" aria-hidden="true">
        <!-- Head -->
        <ellipse cx="500" cy="520" rx="360" ry="430" fill="#ffe6cc" stroke="#e2c2a1" stroke-width="8"/>
        <!-- Ears -->
        <ellipse cx="160" cy="520" rx="55" ry="85" fill="#ffe6cc" stroke="#e2c2a1" stroke-width="6"/>
        <ellipse cx="840" cy="520" rx="55" ry="85" fill="#ffe6cc" stroke="#e2c2a1" stroke-width="6"/>
        <!-- Eyes -->
        <ellipse cx="385" cy="470" rx="65" ry="45" fill="#fff" stroke="#ccc" stroke-width="6"/>
        <ellipse cx="615" cy="470" rx="65" ry="45" fill="#fff" stroke="#ccc" stroke-width="6"/>
        <circle cx="405" cy="475" r="18" fill="#222"/>
        <circle cx="635" cy="475" r="18" fill="#222"/>
        <!-- Nose -->
        <path d="M500 480 C520 540,480 600,500 630" fill="none" stroke="#cc9a7a" stroke-width="10" stroke-linecap="round"/>
        <!-- Mouth -->
        <path d="M380 690 Q500 760 620 690" fill="none" stroke="#cc4d4d" stroke-width="14" stroke-linecap="round"/>
        <!-- Subtle guides -->
        <path d="M240 300 C340 160,660 160,760 300" fill="none" stroke="#eee" stroke-width="24" stroke-linecap="round"/>
        <path d="M320 740 C420 820,580 820,680 740" fill="none" stroke="#eee" stroke-width="24" stroke-linecap="round"/>
        <path d="M320 420 C340 400,430 400,450 420" fill="none" stroke="#eee" stroke-width="18" stroke-linecap="round"/>
        <path d="M550 420 C570 400,660 400,680 420" fill="none" stroke="#eee" stroke-width="18" stroke-linecap="round"/>
      </svg>

      <!-- Iron filings -->
      <canvas id="filings" width="1000" height="1000"></canvas>
    </div>
  </div>

  <footer>Tip: Increase magnet strength, then sketch with your finger. Shake to clear on mobile.</footer>

<script>
/* ---------------- Config ---------------- */
const CANVAS_SIZE = 1000;             // internal resolution
const SAVE_KEY = 'wooly_willy_particles_v2';
const SAVE_EVERY_MS = 1500;

// Physics tuning (prevents collapse)
const BASE_GRAVITY = 0.03;            // was higher; now gentle
const STATIC_FRICTION = 0.92;         // stickiness when nearly still
const DYNAMIC_FRICTION = 0.90;        // normal movement friction
const MAX_SPEED = 10.0;               // avoid crazy velocities
const REPULSION_RADIUS = 6;           // neighbor push radius
const REPULSION_STRENGTH = 0.18;      // separation force (tuned)
const MAGNET_MAX = 1.15;              // slider maps 0..100 to 0..this
const MAGNET_BASE_PULL = 1800;        // magnet constant
const MAGNET_CORE = 10;               // soft core (no infinite pull at 0)
const JITTER = 0.05;                  // tiny noise to avoid jams

// Region where filings are "tray" (easier to return)
const TRAY_Y_MIN = 820;

/* ---------------- Elements ---------------- */
const stage = document.getElementById('stage');
const canvas = document.getElementById('filings');
const ctx = canvas.getContext('2d');
const strengthInput = document.getElementById('strength');
const countInput = document.getElementById('count');
const countLabel = document.getElementById('countLabel');
const clearBtn = document.getElementById('clearBtn');
const reseedBtn = document.getElementById('reseedBtn');

/* ---------------- State ---------------- */
let particles = []; // {x,y,vx,vy,stuck}
let pointer = { x: CANVAS_SIZE/2, y: CANVAS_SIZE/2, active: false };
let magnetStrength = mapRange(+strengthInput.value, 0, 100, 0, MAGNET_MAX);
let targetCount = +countInput.value;
let lastSave = 0;
let grid = null;    // spatial grid for neighbor repulsion

/* ---------------- Utils ---------------- */
function mapRange(v,inMin,inMax,outMin,outMax){ return outMin + ((v-inMin)*(outMax-outMin))/(inMax-inMin); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function rand(min,max){ return Math.random()*(max-min)+min; }
function fmt(n){ return n.toLocaleString(); }

/* ---------------- Persistence ---------------- */
function saveState(){
  try {
    const compact = particles.map(p => [p.x, p.y, p.vx, p.vy, p.stuck?1:0]);
    localStorage.setItem(SAVE_KEY, JSON.stringify(compact));
  } catch(e){}
}
function loadState(){
  try {
    const raw = localStorage.getItem(SAVE_KEY);
    if(!raw) return null;
    const arr = JSON.parse(raw);
    return arr.map(([x,y,vx,vy,st]) => ({x,y,vx,vy,stuck:!!st}));
  } catch(e){ return null; }
}

/* ---------------- Seeding ---------------- */
function seedParticles(n){
  particles = [];
  // place some in tray, some around scalp region so you start with “hair”
  const scalpBand = { yMin: 250, yMax: 360, xMin: 220, xMax: 780 };
  const trayShare = Math.max(0.35, 1 - (n/8000)); // more hair → proportionally fewer in tray
  const inTray = Math.floor(n * trayShare);
  const onHead = n - inTray;

  for(let i=0;i<inTray;i++){
    particles.push({ x: rand(150,850), y: rand(TRAY_Y_MIN,960), vx:0, vy:0, stuck:false });
  }
  for(let i=0;i<onHead;i++){
    particles.push({ x: rand(scalpBand.xMin, scalpBand.xMax), y: rand(scalpBand.yMin, scalpBand.yMax), vx:0, vy:0, stuck:true });
  }
}

/* ---------------- Spatial Hash for Repulsion ---------------- */
const CELL = 12; // >= REPULSION_RADIUS*2 for efficiency
function buildGrid(){
  const cols = Math.ceil(CANVAS_SIZE / CELL);
  const rows = Math.ceil(CANVAS_SIZE / CELL);
  grid = new Array(cols*rows);
  for(let i=0;i<grid.length;i++) grid[i] = [];
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    const cx = Math.floor(p.x / CELL);
    const cy = Math.floor(p.y / CELL);
    const idx = cy*cols + cx;
    if (grid[idx]) grid[idx].push(i);
  }
  grid._cols = cols; grid._rows = rows;
}
function neighbors(i){
  const res = [];
  const p = particles[i];
  const cx = Math.floor(p.x / CELL);
  const cy = Math.floor(p.y / CELL);
  for(let oy=-1; oy<=1; oy++){
    for(let ox=-1; ox<=1; ox++){
      const nx = cx + ox, ny = cy + oy;
      if (nx < 0 || ny < 0 || nx >= grid._cols || ny >= grid._rows) continue;
      const idx = ny*grid._cols + nx;
      const cell = grid[idx];
      for(const j of cell){ if (j !== i) res.push(j); }
    }
  }
  return res;
}

/* ---------------- Simulation Step ---------------- */
function step(dt){
  // spatial grid for repulsion
  buildGrid();

  // physics
  for(let i=0;i<particles.length;i++){
    const p = particles[i];

    // Magnet attraction (softer falloff near pointer)
    if(pointer.active){
      const dx = pointer.x - p.x;
      const dy = pointer.y - p.y;
      const dist = Math.hypot(dx, dy);
      const falloff = MAGNET_BASE_PULL / ((dist + MAGNET_CORE) * (dist + MAGNET_CORE));
      const force = magnetStrength * falloff;
      // steer but don't let everything collapse to exact center
      const pull = clamp(force, 0, 0.9);
      p.vx += dx * pull * dt;
      p.vy += dy * pull * dt;

      // If close enough and above tray, increase “stickiness”
      if (dist < 14 && p.y < TRAY_Y_MIN - 10) {
        p.stuck = true;
      }
    }

    // Gentle gravity unless very “stuck”
    if (!p.stuck) p.vy += BASE_GRAVITY * dt;
    else p.vy += BASE_GRAVITY * 0.15 * dt; // tiny tug even when stuck

    // Neighbor repulsion to prevent collapse/clumping
    const neigh = neighbors(i);
    for(const j of neigh){
      const q = particles[j];
      const dx = p.x - q.x;
      const dy = p.y - q.y;
      const d2 = dx*dx + dy*dy;
      if (d2 > 0 && d2 < (REPULSION_RADIUS*REPULSION_RADIUS)){
        const d = Math.sqrt(d2);
        const push = (REPULSION_RADIUS - d) / REPULSION_RADIUS;
        const nx = dx / d, ny = dy / d;
        // symmetric push apart
        const s = REPULSION_STRENGTH * push * dt;
        p.vx += nx * s; p.vy += ny * s;
        q.vx -= nx * s; q.vy -= ny * s;
      }
    }

    // Small jitter so piles don’t “jam”
    p.vx += (Math.random()-0.5) * JITTER * dt;
    p.vy += (Math.random()-0.5) * JITTER * dt;

    // Friction: stronger if moving slowly or p is stuck
    const v = Math.hypot(p.vx, p.vy);
    const fr = (p.stuck || v < 0.6) ? STATIC_FRICTION : DYNAMIC_FRICTION;
    p.vx *= fr; p.vy *= fr;

    // Speed cap
    const sp = Math.hypot(p.vx, p.vy);
    if (sp > MAX_SPEED){
      p.vx = (p.vx / sp) * MAX_SPEED;
      p.vy = (p.vy / sp) * MAX_SPEED;
    }

    // Integrate
    p.x += p.vx; p.y += p.vy;

    // Bounds
    if(p.x < 20){ p.x = 20; p.vx *= -0.3; }
    if(p.x > CANVAS_SIZE-20){ p.x = CANVAS_SIZE-20; p.vx *= -0.3; }
    if(p.y < 20){ p.y = 20; p.vy *= -0.3; }
    if(p.y > CANVAS_SIZE-20){ p.y = CANVAS_SIZE-20; p.vy *= -0.3; }

    // If back in tray, reduce stickiness so they’re mobile again
    if (p.y >= TRAY_Y_MIN) p.stuck = false;
  }
}

/* ---------------- Rendering ---------------- */
function drawParticles(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#222';
  // Batch path (faster than many beginPath calls)
  ctx.beginPath();
  for(const p of particles){
    // tiny circles
    ctx.moveTo(p.x+2, p.y);
    ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
  }
  ctx.fill();
}

/* ---------------- Input ---------------- */
function stageToCanvas(clientX, clientY){
  const rect = stage.getBoundingClientRect();
  const x = (clientX - rect.left) * (CANVAS_SIZE / rect.width);
  const y = (clientY - rect.top)  * (CANVAS_SIZE / rect.height);
  return {x,y};
}
stage.addEventListener('pointerdown', e=>{
  pointer.active = true;
  const p = stageToCanvas(e.clientX, e.clientY);
  pointer.x = p.x; pointer.y = p.y;
});
stage.addEventListener('pointermove', e=>{
  if(!pointer.active) return;
  const p = stageToCanvas(e.clientX, e.clientY);
  pointer.x = p.x; pointer.y = p.y;
});
window.addEventListener('pointerup', ()=>{ pointer.active = false; });

stage.addEventListener('touchstart', e=>{
  pointer.active = true;
  const t = e.touches[0];
  const p = stageToCanvas(t.clientX, t.clientY);
  pointer.x = p.x; pointer.y = p.y;
},{passive:true});
stage.addEventListener('touchmove', e=>{
  const t = e.touches[0];
  const p = stageToCanvas(t.clientX, t.clientY);
  pointer.x = p.x; pointer.y = p.y;
},{passive:true});
stage.addEventListener('touchend', ()=>{ pointer.active = false; });

/* ---------------- Controls ---------------- */
strengthInput.addEventListener('input', ()=>{
  magnetStrength = mapRange(+strengthInput.value, 0, 100, 0, MAGNET_MAX);
});
countInput.addEventListener('input', ()=>{
  targetCount = +countInput.value;
  countLabel.textContent = fmt(targetCount);
});
reseedBtn.addEventListener('click', ()=>{
  seedParticles(targetCount);
  saveState();
});
clearBtn.addEventListener('click', ()=>{
  // Return filings to tray (don’t change total count)
  for(const p of particles){
    p.vx = p.vy = 0;
    p.x = rand(150, 850);
    p.y = rand(TRAY_Y_MIN, 960);
    p.stuck = false;
  }
  saveState();
});

/* ---------------- Shake-to-clear ---------------- */
if (window.DeviceMotionEvent){
  let lastShake = 0;
  window.addEventListener('devicemotion', e=>{
    const a = e.accelerationIncludingGravity || {};
    const strength = Math.abs(a.x||0)+Math.abs(a.y||0)+Math.abs(a.z||0);
    if (strength > 40 && Date.now()-lastShake>1200){
      clearBtn.click();
      lastShake = Date.now();
    }
  });
}

/* ---------------- Animation Loop ---------------- */
let last = performance.now();
let lastSaveTS = performance.now();
function loop(now){
  const dt = Math.min(32, now - last) / 16.67; // normalize ~60fps
  last = now;
  step(dt);
  drawParticles();

  if (now - lastSaveTS > SAVE_EVERY_MS){
    saveState();
    lastSaveTS = now;
  }
  requestAnimationFrame(loop);
}

/* ---------------- Init ---------------- */
(function init(){
  const loaded = loadState();
  if (loaded && loaded.length){
    particles = loaded;
    targetCount = loaded.length;
    countInput.value = targetCount;
    countLabel.textContent = fmt(targetCount);
  } else {
    seedParticles(targetCount);
  }
  // initial render and start loop
  drawParticles();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
